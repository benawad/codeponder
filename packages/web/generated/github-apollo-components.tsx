export type Maybe<T> = T | null;

/** Ordering options for repository connections */
export interface RepositoryOrder {
  /** The field to order repositories by. */
  field: RepositoryOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Ways in which star connections can be ordered. */
export interface StarOrder {
  /** The field in which to order nodes by. */
  field: StarOrderField;
  /** The direction in which to order nodes. */
  direction: OrderDirection;
}
/** Ways in which lists of issues can be ordered upon return. */
export interface IssueOrder {
  /** The field in which to order issues by. */
  field: IssueOrderField;
  /** The direction in which to order issues by the specified field. */
  direction: OrderDirection;
}
/** Ways in which lists of reactions can be ordered upon return. */
export interface ReactionOrder {
  /** The field in which to order reactions by. */
  field: ReactionOrderField;
  /** The direction in which to order reactions by the specified field. */
  direction: OrderDirection;
}
/** Specifies an author for filtering Git commits. */
export interface CommitAuthor {
  /** ID of a User to filter by. If non-null, only commits authored by this user will be returned. This field takes precedence over emails. */
  id?: Maybe<string>;
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: Maybe<string[]>;
}
/** Ways in which team connections can be ordered. */
export interface TeamOrder {
  /** The field in which to order nodes by. */
  field: TeamOrderField;
  /** The direction in which to order nodes. */
  direction: OrderDirection;
}
/** Ordering options for team member connections */
export interface TeamMemberOrder {
  /** The field to order team members by. */
  field: TeamMemberOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Ordering options for team repository connections */
export interface TeamRepositoryOrder {
  /** The field to order repositories by. */
  field: TeamRepositoryOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Ordering options for language connections. */
export interface LanguageOrder {
  /** The field to order languages by. */
  field: LanguageOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Ordering options for milestone connections. */
export interface MilestoneOrder {
  /** The field to order milestones by. */
  field: MilestoneOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Ways in which lists of projects can be ordered upon return. */
export interface ProjectOrder {
  /** The field in which to order projects by. */
  field: ProjectOrderField;
  /** The direction in which to order projects by the specified field. */
  direction: OrderDirection;
}
/** Ways in which lists of git refs can be ordered upon return. */
export interface RefOrder {
  /** The field in which to order refs by. */
  field: RefOrderField;
  /** The direction in which to order refs by the specified field. */
  direction: OrderDirection;
}
/** Ways in which lists of releases can be ordered upon return. */
export interface ReleaseOrder {
  /** The field in which to order releases by. */
  field: ReleaseOrderField;
  /** The direction in which to order releases by the specified field. */
  direction: OrderDirection;
}
/** Ordering options for gist connections */
export interface GistOrder {
  /** The field to order repositories by. */
  field: GistOrderField;
  /** The ordering direction. */
  direction: OrderDirection;
}
/** Autogenerated input type of AcceptTopicSuggestion */
export interface AcceptTopicSuggestionInput {
  /** The Node ID of the repository. */
  repositoryId: string;
  /** The name of the suggested topic. */
  name: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddComment */
export interface AddCommentInput {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** The contents of the comment. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddProjectCard */
export interface AddProjectCardInput {
  /** The Node ID of the ProjectColumn. */
  projectColumnId: string;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: Maybe<string>;
  /** The note on the card. */
  note?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddProjectColumn */
export interface AddProjectColumnInput {
  /** The Node ID of the project. */
  projectId: string;
  /** The name of the column. */
  name: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddPullRequestReview */
export interface AddPullRequestReviewInput {
  /** The Node ID of the pull request to modify. */
  pullRequestId: string;
  /** The commit OID the review pertains to. */
  commitOID?: Maybe<GitObjectId>;
  /** The contents of the review body comment. */
  body?: Maybe<string>;
  /** The event to perform on the pull request review. */
  event?: Maybe<PullRequestReviewEvent>;
  /** The review line comments. */
  comments?: Maybe<DraftPullRequestReviewComment[]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Specifies a review comment to be left with a Pull Request Review. */
export interface DraftPullRequestReviewComment {
  /** Path to the file being commented on. */
  path: string;
  /** Position in the file to leave a comment on. */
  position: number;
  /** Body of the comment to leave. */
  body: string;
}
/** Autogenerated input type of AddPullRequestReviewComment */
export interface AddPullRequestReviewCommentInput {
  /** The Node ID of the review to modify. */
  pullRequestReviewId: string;
  /** The SHA of the commit to comment on. */
  commitOID?: Maybe<GitObjectId>;
  /** The text of the comment. */
  body: string;
  /** The relative path of the file to comment on. */
  path?: Maybe<string>;
  /** The line index in the diff to comment on. */
  position?: Maybe<number>;
  /** The comment id to reply to. */
  inReplyTo?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddReaction */
export interface AddReactionInput {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** The name of the emoji to react with. */
  content: ReactionContent;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of AddStar */
export interface AddStarInput {
  /** The Starrable ID to star. */
  starrableId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of CreateBranchProtectionRule */
export interface CreateBranchProtectionRuleInput {
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: string;
  /** The glob-like pattern used to determine matching branches. */
  pattern: string;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<boolean>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<number>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<boolean>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<boolean>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<boolean>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<boolean>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<boolean>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<boolean>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<boolean>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<string[]>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<boolean>;
  /** A list of User or Team IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<string[]>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<string[]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of CreateProject */
export interface CreateProjectInput {
  /** The owner ID to create the project under. */
  ownerId: string;
  /** The name of project. */
  name: string;
  /** The description of project. */
  body?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeclineTopicSuggestion */
export interface DeclineTopicSuggestionInput {
  /** The Node ID of the repository. */
  repositoryId: string;
  /** The name of the suggested topic. */
  name: string;
  /** The reason why the suggested topic is declined. */
  reason: TopicSuggestionDeclineReason;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeleteBranchProtectionRule */
export interface DeleteBranchProtectionRuleInput {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeleteProject */
export interface DeleteProjectInput {
  /** The Project ID to update. */
  projectId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeleteProjectCard */
export interface DeleteProjectCardInput {
  /** The id of the card to delete. */
  cardId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeleteProjectColumn */
export interface DeleteProjectColumnInput {
  /** The id of the column to delete. */
  columnId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DeletePullRequestReview */
export interface DeletePullRequestReviewInput {
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of DismissPullRequestReview */
export interface DismissPullRequestReviewInput {
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: string;
  /** The contents of the pull request review dismissal message. */
  message: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of LockLockable */
export interface LockLockableInput {
  /** ID of the issue or pull request to be locked. */
  lockableId: string;
  /** A reason for why the issue or pull request will be locked. */
  lockReason?: Maybe<LockReason>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of MoveProjectCard */
export interface MoveProjectCardInput {
  /** The id of the card to move. */
  cardId: string;
  /** The id of the column to move it into. */
  columnId: string;
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of MoveProjectColumn */
export interface MoveProjectColumnInput {
  /** The id of the column to move. */
  columnId: string;
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of RemoveOutsideCollaborator */
export interface RemoveOutsideCollaboratorInput {
  /** The ID of the outside collaborator to remove. */
  userId: string;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of RemoveReaction */
export interface RemoveReactionInput {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** The name of the emoji reaction to remove. */
  content: ReactionContent;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of RemoveStar */
export interface RemoveStarInput {
  /** The Starrable ID to unstar. */
  starrableId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of RequestReviews */
export interface RequestReviewsInput {
  /** The Node ID of the pull request to modify. */
  pullRequestId: string;
  /** The Node IDs of the user to request. */
  userIds?: Maybe<string[]>;
  /** The Node IDs of the team to request. */
  teamIds?: Maybe<string[]>;
  /** Add users to the set rather than replace. */
  union?: Maybe<boolean>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of SubmitPullRequestReview */
export interface SubmitPullRequestReviewInput {
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId: string;
  /** The event to send to the Pull Request Review. */
  event: PullRequestReviewEvent;
  /** The text field to set on the Pull Request Review. */
  body?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UnlockLockable */
export interface UnlockLockableInput {
  /** ID of the issue or pull request to be unlocked. */
  lockableId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateBranchProtectionRule */
export interface UpdateBranchProtectionRuleInput {
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: string;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: Maybe<string>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: Maybe<boolean>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<number>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: Maybe<boolean>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: Maybe<boolean>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: Maybe<boolean>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: Maybe<boolean>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: Maybe<boolean>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: Maybe<boolean>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: Maybe<boolean>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: Maybe<string[]>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: Maybe<boolean>;
  /** A list of User or Team IDs allowed to push to matching branches. */
  pushActorIds?: Maybe<string[]>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<string[]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateProject */
export interface UpdateProjectInput {
  /** The Project ID to update. */
  projectId: string;
  /** The name of project. */
  name?: Maybe<string>;
  /** The description of project. */
  body?: Maybe<string>;
  /** Whether the project is open or closed. */
  state?: Maybe<ProjectState>;
  /** Whether the project is public or not. */
  public?: Maybe<boolean>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateProjectCard */
export interface UpdateProjectCardInput {
  /** The ProjectCard ID to update. */
  projectCardId: string;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: Maybe<boolean>;
  /** The note of ProjectCard. */
  note?: Maybe<string>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateProjectColumn */
export interface UpdateProjectColumnInput {
  /** The ProjectColumn ID to update. */
  projectColumnId: string;
  /** The name of project column. */
  name: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdatePullRequestReview */
export interface UpdatePullRequestReviewInput {
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: string;
  /** The contents of the pull request review body. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdatePullRequestReviewComment */
export interface UpdatePullRequestReviewCommentInput {
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: string;
  /** The text of the comment. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateSubscription */
export interface UpdateSubscriptionInput {
  /** The Node ID of the subscribable object to modify. */
  subscribableId: string;
  /** The new state of the subscription. */
  state: SubscriptionState;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UpdateTopics */
export interface UpdateTopicsInput {
  /** The Node ID of the repository. */
  repositoryId: string;
  /** An array of topic names. */
  topicNames: string[];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of CreateContentAttachment */
export interface CreateContentAttachmentInput {
  /** The node ID of the content_reference. */
  contentReferenceId: string;
  /** The title of the content attachment. */
  title: string;
  /** The body of the content attachment, which may contain markdown. */
  body: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of MinimizeComment */
export interface MinimizeCommentInput {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** The classification of comment */
  classifier: ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Ways in which lists of issues can be ordered upon return. */
export interface PullRequestOrder {
  /** The field in which to order pull requests by. */
  field: PullRequestOrderField;
  /** The direction in which to order pull requests by the specified field. */
  direction: OrderDirection;
}
/** Autogenerated input type of ResolveReviewThread */
export interface ResolveReviewThreadInput {
  /** The ID of the thread to resolve */
  threadId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UnminimizeComment */
export interface UnminimizeCommentInput {
  /** The Node ID of the subject to modify. */
  subjectId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** Autogenerated input type of UnresolveReviewThread */
export interface UnresolveReviewThreadInput {
  /** The ID of the thread to unresolve */
  threadId: string;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<string>;
}
/** The possible archived states of a project card. */
export enum ProjectCardArchivedState {
  Archived = "ARCHIVED",
  NotArchived = "NOT_ARCHIVED",
}
/** The privacy of a repository */
export enum RepositoryPrivacy {
  Public = "PUBLIC",
  Private = "PRIVATE",
}
/** Properties by which repository connections can be ordered. */
export enum RepositoryOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  PushedAt = "PUSHED_AT",
  Name = "NAME",
  Stargazers = "STARGAZERS",
}
/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  Asc = "ASC",
  Desc = "DESC",
}
/** The affiliation of a user to a repository */
export enum RepositoryAffiliation {
  Owner = "OWNER",
  Collaborator = "COLLABORATOR",
  OrganizationMember = "ORGANIZATION_MEMBER",
}
/** The possible states of a subscription. */
export enum SubscriptionState {
  Unsubscribed = "UNSUBSCRIBED",
  Subscribed = "SUBSCRIBED",
  Ignored = "IGNORED",
}
/** Properties by which star connections can be ordered. */
export enum StarOrderField {
  StarredAt = "STARRED_AT",
}
/** The possible reasons a given repository could be in a locked state. */
export enum RepositoryLockReason {
  Moving = "MOVING",
  Billing = "BILLING",
  Rename = "RENAME",
  Migrating = "MIGRATING",
}
/** The possible states of a pull request. */
export enum PullRequestState {
  Open = "OPEN",
  Closed = "CLOSED",
  Merged = "MERGED",
}
/** Properties by which issue connections can be ordered. */
export enum IssueOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  Comments = "COMMENTS",
}
/** A comment author association with repository. */
export enum CommentAuthorAssociation {
  Member = "MEMBER",
  Owner = "OWNER",
  Collaborator = "COLLABORATOR",
  Contributor = "CONTRIBUTOR",
  FirstTimeContributor = "FIRST_TIME_CONTRIBUTOR",
  FirstTimer = "FIRST_TIMER",
  None = "NONE",
}
/** The possible errors that will prevent a user from updating a comment. */
export enum CommentCannotUpdateReason {
  InsufficientAccess = "INSUFFICIENT_ACCESS",
  Locked = "LOCKED",
  LoginRequired = "LOGIN_REQUIRED",
  Maintenance = "MAINTENANCE",
  VerifiedEmailRequired = "VERIFIED_EMAIL_REQUIRED",
  Denied = "DENIED",
}
/** The possible states of an issue. */
export enum IssueState {
  Open = "OPEN",
  Closed = "CLOSED",
}
/** The possible reasons that an issue or pull request was locked. */
export enum LockReason {
  OffTopic = "OFF_TOPIC",
  TooHeated = "TOO_HEATED",
  Resolved = "RESOLVED",
  Spam = "SPAM",
}
/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum ReactionContent {
  ThumbsUp = "THUMBS_UP",
  ThumbsDown = "THUMBS_DOWN",
  Laugh = "LAUGH",
  Hooray = "HOORAY",
  Confused = "CONFUSED",
  Heart = "HEART",
}
/** A list of fields that reactions can be ordered by. */
export enum ReactionOrderField {
  CreatedAt = "CREATED_AT",
}
/** The state of a Git signature. */
export enum GitSignatureState {
  Valid = "VALID",
  Invalid = "INVALID",
  MalformedSig = "MALFORMED_SIG",
  UnknownKey = "UNKNOWN_KEY",
  BadEmail = "BAD_EMAIL",
  UnverifiedEmail = "UNVERIFIED_EMAIL",
  NoUser = "NO_USER",
  UnknownSigType = "UNKNOWN_SIG_TYPE",
  Unsigned = "UNSIGNED",
  GpgverifyUnavailable = "GPGVERIFY_UNAVAILABLE",
  GpgverifyError = "GPGVERIFY_ERROR",
  NotSigningKey = "NOT_SIGNING_KEY",
  ExpiredKey = "EXPIRED_KEY",
  OcspPending = "OCSP_PENDING",
  OcspError = "OCSP_ERROR",
  BadCert = "BAD_CERT",
  OcspRevoked = "OCSP_REVOKED",
}
/** The possible commit status states. */
export enum StatusState {
  Expected = "EXPECTED",
  Error = "ERROR",
  Failure = "FAILURE",
  Pending = "PENDING",
  Success = "SUCCESS",
}
/** Whether or not a PullRequest can be merged. */
export enum MergeableState {
  Mergeable = "MERGEABLE",
  Conflicting = "CONFLICTING",
  Unknown = "UNKNOWN",
}
/** The possible states of a milestone. */
export enum MilestoneState {
  Open = "OPEN",
  Closed = "CLOSED",
}
/** Properties by which team connections can be ordered. */
export enum TeamOrderField {
  Name = "NAME",
}
/** The possible organization invitation types. */
export enum OrganizationInvitationType {
  User = "USER",
  Email = "EMAIL",
}
/** The possible organization invitation roles. */
export enum OrganizationInvitationRole {
  DirectMember = "DIRECT_MEMBER",
  Admin = "ADMIN",
  BillingManager = "BILLING_MANAGER",
  Reinstate = "REINSTATE",
}
/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum TeamMembershipType {
  Immediate = "IMMEDIATE",
  ChildTeam = "CHILD_TEAM",
  All = "ALL",
}
/** The possible team member roles; either 'maintainer' or 'member'. */
export enum TeamMemberRole {
  Maintainer = "MAINTAINER",
  Member = "MEMBER",
}
/** Properties by which team member connections can be ordered. */
export enum TeamMemberOrderField {
  Login = "LOGIN",
  CreatedAt = "CREATED_AT",
}
/** The possible team privacy values. */
export enum TeamPrivacy {
  Secret = "SECRET",
  Visible = "VISIBLE",
}
/** Properties by which team repository connections can be ordered. */
export enum TeamRepositoryOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  PushedAt = "PUSHED_AT",
  Name = "NAME",
  Permission = "PERMISSION",
  Stargazers = "STARGAZERS",
}
/** The access level to a repository */
export enum RepositoryPermission {
  Admin = "ADMIN",
  Write = "WRITE",
  Read = "READ",
}
/** The possible states of a pull request review. */
export enum PullRequestReviewState {
  Pending = "PENDING",
  Commented = "COMMENTED",
  Approved = "APPROVED",
  ChangesRequested = "CHANGES_REQUESTED",
  Dismissed = "DISMISSED",
}
/** The possible states of a pull request review comment. */
export enum PullRequestReviewCommentState {
  Pending = "PENDING",
  Submitted = "SUBMITTED",
}
/** The possible states for a deployment status. */
export enum DeploymentStatusState {
  Pending = "PENDING",
  Success = "SUCCESS",
  Failure = "FAILURE",
  Inactive = "INACTIVE",
  Error = "ERROR",
}
/** The possible states in which a deployment can be. */
export enum DeploymentState {
  Abandoned = "ABANDONED",
  Active = "ACTIVE",
  Destroyed = "DESTROYED",
  Error = "ERROR",
  Failure = "FAILURE",
  Inactive = "INACTIVE",
  Pending = "PENDING",
}
/** Collaborators affiliation level with a subject. */
export enum CollaboratorAffiliation {
  Outside = "OUTSIDE",
  Direct = "DIRECT",
  All = "ALL",
}
/** Properties by which language connections can be ordered. */
export enum LanguageOrderField {
  Size = "SIZE",
}
/** Properties by which milestone connections can be ordered. */
export enum MilestoneOrderField {
  DueDate = "DUE_DATE",
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  Number = "NUMBER",
}
/** Properties by which project connections can be ordered. */
export enum ProjectOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  Name = "NAME",
}
/** State of the project; either 'open' or 'closed' */
export enum ProjectState {
  Open = "OPEN",
  Closed = "CLOSED",
}
/** Properties by which ref connections can be ordered. */
export enum RefOrderField {
  TagCommitDate = "TAG_COMMIT_DATE",
  Alphabetical = "ALPHABETICAL",
}
/** Properties by which release connections can be ordered. */
export enum ReleaseOrderField {
  CreatedAt = "CREATED_AT",
  Name = "NAME",
}
/** The privacy of a Gist */
export enum GistPrivacy {
  Public = "PUBLIC",
  Secret = "SECRET",
  All = "ALL",
}
/** Properties by which gist connections can be ordered. */
export enum GistOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
  PushedAt = "PUSHED_AT",
}
/** The reason a repository is listed as 'contributed'. */
export enum RepositoryContributionType {
  Commit = "COMMIT",
  Issue = "ISSUE",
  PullRequest = "PULL_REQUEST",
  Repository = "REPOSITORY",
  PullRequestReview = "PULL_REQUEST_REVIEW",
}
/** Various content states of a ProjectCard */
export enum ProjectCardState {
  ContentOnly = "CONTENT_ONLY",
  NoteOnly = "NOTE_ONLY",
  Redacted = "REDACTED",
}
/** The semantic purpose of the column - todo, in progress, or done. */
export enum ProjectColumnPurpose {
  Todo = "TODO",
  InProgress = "IN_PROGRESS",
  Done = "DONE",
}
/** The possible roles within an organization for its members. */
export enum OrganizationMemberRole {
  Member = "MEMBER",
  Admin = "ADMIN",
}
/** The role of a user on a team. */
export enum TeamRole {
  Admin = "ADMIN",
  Member = "MEMBER",
}
/** Represents the individual results of a search. */
export enum SearchType {
  Issue = "ISSUE",
  Repository = "REPOSITORY",
  User = "USER",
}
/** The possible events to perform on a pull request review. */
export enum PullRequestReviewEvent {
  Comment = "COMMENT",
  Approve = "APPROVE",
  RequestChanges = "REQUEST_CHANGES",
  Dismiss = "DISMISS",
}
/** Reason that the suggested topic is declined. */
export enum TopicSuggestionDeclineReason {
  NotRelevant = "NOT_RELEVANT",
  TooSpecific = "TOO_SPECIFIC",
  PersonalPreference = "PERSONAL_PREFERENCE",
  TooGeneral = "TOO_GENERAL",
}
/** The possible default permissions for repositories. */
export enum DefaultRepositoryPermissionField {
  None = "NONE",
  Read = "READ",
  Write = "WRITE",
  Admin = "ADMIN",
}
/** The possible PubSub channels for an issue. */
export enum IssuePubSubTopic {
  Updated = "UPDATED",
  Markasread = "MARKASREAD",
  Timeline = "TIMELINE",
  State = "STATE",
}
/** The possible item types found in a timeline. */
export enum IssueTimelineItemsItemType {
  IssueComment = "ISSUE_COMMENT",
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  AssignedEvent = "ASSIGNED_EVENT",
  ClosedEvent = "CLOSED_EVENT",
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  DemilestonedEvent = "DEMILESTONED_EVENT",
  LabeledEvent = "LABELED_EVENT",
  LockedEvent = "LOCKED_EVENT",
  MentionedEvent = "MENTIONED_EVENT",
  MilestonedEvent = "MILESTONED_EVENT",
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  ReferencedEvent = "REFERENCED_EVENT",
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  ReopenedEvent = "REOPENED_EVENT",
  SubscribedEvent = "SUBSCRIBED_EVENT",
  TransferredEvent = "TRANSFERRED_EVENT",
  UnassignedEvent = "UNASSIGNED_EVENT",
  UnlabeledEvent = "UNLABELED_EVENT",
  UnlockedEvent = "UNLOCKED_EVENT",
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
}
/** The reasons a piece of content can be reported or minimized. */
export enum ReportedContentClassifiers {
  Spam = "SPAM",
  Abuse = "ABUSE",
  OffTopic = "OFF_TOPIC",
  Outdated = "OUTDATED",
  Resolved = "RESOLVED",
}
/** Properties by which pull_requests connections can be ordered. */
export enum PullRequestOrderField {
  CreatedAt = "CREATED_AT",
  UpdatedAt = "UPDATED_AT",
}
/** The possible PubSub channels for a pull request. */
export enum PullRequestPubSubTopic {
  Updated = "UPDATED",
  Markasread = "MARKASREAD",
  HeadRef = "HEAD_REF",
  Timeline = "TIMELINE",
  State = "STATE",
}
/** The possible item types found in a timeline. */
export enum PullRequestTimelineItemsItemType {
  PullRequestCommit = "PULL_REQUEST_COMMIT",
  PullRequestCommitCommentThread = "PULL_REQUEST_COMMIT_COMMENT_THREAD",
  PullRequestReview = "PULL_REQUEST_REVIEW",
  PullRequestReviewThread = "PULL_REQUEST_REVIEW_THREAD",
  PullRequestRevisionMarker = "PULL_REQUEST_REVISION_MARKER",
  BaseRefChangedEvent = "BASE_REF_CHANGED_EVENT",
  BaseRefForcePushedEvent = "BASE_REF_FORCE_PUSHED_EVENT",
  DeployedEvent = "DEPLOYED_EVENT",
  DeploymentEnvironmentChangedEvent = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT",
  HeadRefDeletedEvent = "HEAD_REF_DELETED_EVENT",
  HeadRefForcePushedEvent = "HEAD_REF_FORCE_PUSHED_EVENT",
  HeadRefRestoredEvent = "HEAD_REF_RESTORED_EVENT",
  MergedEvent = "MERGED_EVENT",
  ReviewDismissedEvent = "REVIEW_DISMISSED_EVENT",
  ReviewRequestedEvent = "REVIEW_REQUESTED_EVENT",
  ReviewRequestRemovedEvent = "REVIEW_REQUEST_REMOVED_EVENT",
  IssueComment = "ISSUE_COMMENT",
  CrossReferencedEvent = "CROSS_REFERENCED_EVENT",
  AddedToProjectEvent = "ADDED_TO_PROJECT_EVENT",
  AssignedEvent = "ASSIGNED_EVENT",
  ClosedEvent = "CLOSED_EVENT",
  CommentDeletedEvent = "COMMENT_DELETED_EVENT",
  ConvertedNoteToIssueEvent = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  DemilestonedEvent = "DEMILESTONED_EVENT",
  LabeledEvent = "LABELED_EVENT",
  LockedEvent = "LOCKED_EVENT",
  MentionedEvent = "MENTIONED_EVENT",
  MilestonedEvent = "MILESTONED_EVENT",
  MovedColumnsInProjectEvent = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  ReferencedEvent = "REFERENCED_EVENT",
  RemovedFromProjectEvent = "REMOVED_FROM_PROJECT_EVENT",
  RenamedTitleEvent = "RENAMED_TITLE_EVENT",
  ReopenedEvent = "REOPENED_EVENT",
  SubscribedEvent = "SUBSCRIBED_EVENT",
  TransferredEvent = "TRANSFERRED_EVENT",
  UnassignedEvent = "UNASSIGNED_EVENT",
  UnlabeledEvent = "UNLABELED_EVENT",
  UnlockedEvent = "UNLOCKED_EVENT",
  UnsubscribedEvent = "UNSUBSCRIBED_EVENT",
}
/** The affiliation type between collaborator and repository. */
export enum RepositoryCollaboratorAffiliation {
  All = "ALL",
  Outside = "OUTSIDE",
}

/** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
export type Uri = any;

/** An ISO-8601 encoded UTC date string. */
export type DateTime = any;

/** A string containing HTML code. */
export type Html = any;

/** A Git object ID. */
export type GitObjectId = any;

/** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
export type GitTimestamp = any;

/** Git SSH string */
export type GitSshRemote = any;

/** An ISO-8601 encoded date string. */
export type Date = any;

/** A valid x509 certificate string */
export type X509Certificate = any;

// ====================================================
// Documents
// ====================================================

export type GetRepoVariables = {
  owner: string;
  name: string;
};

export type GetRepoQuery = {
  __typename?: "Query";

  repository: Maybe<GetRepoRepository>;
};

export type GetRepoRepository = RepoInfoFragment;

export type GetRepoObjectVariables = {
  owner: string;
  name: string;
  expression: string;
};

export type GetRepoObjectQuery = {
  __typename?: "Query";

  repository: Maybe<GetRepoObjectRepository>;
};

export type GetRepoObjectRepository = {
  __typename?: "Repository";

  object: Maybe<GetRepoObjectObject>;
};

export type GetRepoObjectObject =
  | GetRepoObjectBlobInlineFragment
  | GetRepoObjectTreeInlineFragment;

export type GetRepoObjectBlobInlineFragment = {
  __typename?: "Blob";

  text: Maybe<string>;
};

export type GetRepoObjectTreeInlineFragment = {
  __typename?: "Tree";

  entries: Maybe<GetRepoObjectEntries[]>;
};

export type GetRepoObjectEntries = {
  __typename?: "TreeEntry";

  type: string;

  name: string;
};

export type GetViewerReposVariables = {};

export type GetViewerReposQuery = {
  __typename?: "Query";

  viewer: GetViewerReposViewer;
};

export type GetViewerReposViewer = {
  __typename?: "User";

  repositories: GetViewerReposRepositories;
};

export type GetViewerReposRepositories = {
  __typename?: "RepositoryConnection";

  totalCount: number;

  edges: Maybe<GetViewerReposEdges[]>;
};

export type GetViewerReposEdges = {
  __typename?: "RepositoryEdge";

  node: Maybe<GetViewerReposNode>;
};

export type GetViewerReposNode = RepoInfoFragment;

export type RepoInfoFragment = {
  __typename?: "Repository";

  name: string;

  description: Maybe<string>;

  owner: RepoInfoOwner;

  defaultBranchRef: Maybe<RepoInfoDefaultBranchRef>;

  languages: Maybe<RepoInfoLanguages>;

  repositoryTopics: RepoInfoRepositoryTopics;
};

export type RepoInfoOwner = {
  __typename?: "RepositoryOwner";

  login: string;
};

export type RepoInfoDefaultBranchRef = {
  __typename?: "Ref";

  name: string;

  target: RepoInfoTarget;
};

export type RepoInfoTarget = {
  __typename: "GitObject";

  oid: GitObjectId;
};

export type RepoInfoLanguages = {
  __typename?: "LanguageConnection";

  edges: Maybe<RepoInfoEdges[]>;
};

export type RepoInfoEdges = {
  __typename?: "LanguageEdge";

  node: RepoInfoNode;

  size: number;
};

export type RepoInfoNode = {
  __typename?: "Language";

  name: string;

  color: Maybe<string>;
};

export type RepoInfoRepositoryTopics = {
  __typename?: "RepositoryTopicConnection";

  edges: Maybe<RepoInfo_Edges[]>;
};

export type RepoInfo_Edges = {
  __typename?: "RepositoryTopicEdge";

  node: Maybe<RepoInfo_Node>;
};

export type RepoInfo_Node = {
  __typename?: "RepositoryTopic";

  topic: RepoInfoTopic;
};

export type RepoInfoTopic = {
  __typename?: "Topic";

  name: string;
};

import * as ReactApollo from "react-apollo";
import * as React from "react";

import gql from "graphql-tag";

// ====================================================
// Fragments
// ====================================================

export const RepoInfoFragmentDoc = gql`
  fragment RepoInfo on Repository {
    name
    description
    owner {
      login
    }
    defaultBranchRef {
      name
      target {
        __typename
        oid
      }
    }
    languages(first: 10) {
      edges {
        node {
          name
          color
        }
        size
      }
    }
    repositoryTopics(first: 10) {
      edges {
        node {
          topic {
            name
          }
        }
      }
    }
  }
`;

// ====================================================
// Components
// ====================================================

export const GetRepoDocument = gql`
  query GetRepo($owner: String!, $name: String!) {
    repository(owner: $owner, name: $name) {
      ...RepoInfo
    }
  }

  ${RepoInfoFragmentDoc}
`;
export class GetRepoComponent extends React.Component<
  Partial<ReactApollo.QueryProps<GetRepoQuery, GetRepoVariables>>
> {
  render() {
    return (
      <ReactApollo.Query<GetRepoQuery, GetRepoVariables>
        query={GetRepoDocument}
        {...(this as any)["props"] as any}
      />
    );
  }
}
export type GetRepoProps<TChildProps = any> = Partial<
  ReactApollo.DataProps<GetRepoQuery, GetRepoVariables>
> &
  TChildProps;
export function GetRepoHOC<TProps, TChildProps = any>(
  operationOptions:
    | ReactApollo.OperationOption<
        TProps,
        GetRepoQuery,
        GetRepoVariables,
        GetRepoProps<TChildProps>
      >
    | undefined
) {
  return ReactApollo.graphql<
    TProps,
    GetRepoQuery,
    GetRepoVariables,
    GetRepoProps<TChildProps>
  >(GetRepoDocument, operationOptions);
}
export const GetRepoObjectDocument = gql`
  query GetRepoObject($owner: String!, $name: String!, $expression: String!) {
    repository(owner: $owner, name: $name) {
      object(expression: $expression) {
        __typename
        ... on Blob {
          text
        }
        ... on Tree {
          entries {
            type
            name
          }
        }
      }
    }
  }
`;
export class GetRepoObjectComponent extends React.Component<
  Partial<ReactApollo.QueryProps<GetRepoObjectQuery, GetRepoObjectVariables>>
> {
  render() {
    return (
      <ReactApollo.Query<GetRepoObjectQuery, GetRepoObjectVariables>
        query={GetRepoObjectDocument}
        {...(this as any)["props"] as any}
      />
    );
  }
}
export type GetRepoObjectProps<TChildProps = any> = Partial<
  ReactApollo.DataProps<GetRepoObjectQuery, GetRepoObjectVariables>
> &
  TChildProps;
export function GetRepoObjectHOC<TProps, TChildProps = any>(
  operationOptions:
    | ReactApollo.OperationOption<
        TProps,
        GetRepoObjectQuery,
        GetRepoObjectVariables,
        GetRepoObjectProps<TChildProps>
      >
    | undefined
) {
  return ReactApollo.graphql<
    TProps,
    GetRepoObjectQuery,
    GetRepoObjectVariables,
    GetRepoObjectProps<TChildProps>
  >(GetRepoObjectDocument, operationOptions);
}
export const GetViewerReposDocument = gql`
  query GetViewerRepos {
    viewer {
      repositories(first: 100) {
        totalCount
        edges {
          node {
            ...RepoInfo
          }
        }
      }
    }
  }

  ${RepoInfoFragmentDoc}
`;
export class GetViewerReposComponent extends React.Component<
  Partial<ReactApollo.QueryProps<GetViewerReposQuery, GetViewerReposVariables>>
> {
  render() {
    return (
      <ReactApollo.Query<GetViewerReposQuery, GetViewerReposVariables>
        query={GetViewerReposDocument}
        {...(this as any)["props"] as any}
      />
    );
  }
}
export type GetViewerReposProps<TChildProps = any> = Partial<
  ReactApollo.DataProps<GetViewerReposQuery, GetViewerReposVariables>
> &
  TChildProps;
export function GetViewerReposHOC<TProps, TChildProps = any>(
  operationOptions:
    | ReactApollo.OperationOption<
        TProps,
        GetViewerReposQuery,
        GetViewerReposVariables,
        GetViewerReposProps<TChildProps>
      >
    | undefined
) {
  return ReactApollo.graphql<
    TProps,
    GetViewerReposQuery,
    GetViewerReposVariables,
    GetViewerReposProps<TChildProps>
  >(GetViewerReposDocument, operationOptions);
}
